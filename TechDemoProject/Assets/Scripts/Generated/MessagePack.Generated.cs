// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Resolvers
{
    using System;

    public class GeneratedResolver : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<Type, int> lookup;

        static GeneratedResolverGetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<Type, int>(47)
            {
                { typeof(global::Tech.Data.EquipmentData[]), 0 },
                { typeof(global::Tech.Data.SkillData[]), 1 },
                { typeof(global::Tech.DB.Equipment[]), 2 },
                { typeof(global::Tech.DB.Item[]), 3 },
                { typeof(global::Tech.DB.Skill[]), 4 },
                { typeof(global::Tech.DB.TechMaterial[]), 5 },
                { typeof(global::Tech.DB.Unit[]), 6 },
                { typeof(global::Tech.DB.Weapon[]), 7 },
                { typeof(global::Tech.Data.DB.Ailment), 8 },
                { typeof(global::Tech.Data.DB.Element), 9 },
                { typeof(global::Tech.Data.DB.EquipmentType), 10 },
                { typeof(global::Tech.Data.DB.ItemType), 11 },
                { typeof(global::Tech.Data.DB.ParameterType), 12 },
                { typeof(global::Tech.Data.DB.RaceType), 13 },
                { typeof(global::Tech.Data.DB.Rarity), 14 },
                { typeof(global::Tech.Data.DB.Target), 15 },
                { typeof(global::Tech.Data.DB.TargetStat), 16 },
                { typeof(global::Tech.Data.DB.TraitType), 17 },
                { typeof(global::Tech.Data.DB.UnitType), 18 },
                { typeof(global::Tech.Data.DB.WeaponType), 19 },
                { typeof(global::Tech.Data.AbilityData), 20 },
                { typeof(global::Tech.Data.DB.AbilityInfo), 21 },
                { typeof(global::Tech.Data.DB.EnemyInfo), 22 },
                { typeof(global::Tech.Data.DB.EquipmentInfo), 23 },
                { typeof(global::Tech.Data.DB.ItemInfo), 24 },
                { typeof(global::Tech.Data.DB.MaterialInfo), 25 },
                { typeof(global::Tech.Data.DB.SkillInfo), 26 },
                { typeof(global::Tech.Data.DB.Stat), 27 },
                { typeof(global::Tech.Data.DB.UnitInfo), 28 },
                { typeof(global::Tech.Data.DB.WeaponInfo), 29 },
                { typeof(global::Tech.Data.EnemyData), 30 },
                { typeof(global::Tech.Data.EquipmentData), 31 },
                { typeof(global::Tech.Data.ItemData), 32 },
                { typeof(global::Tech.Data.MaterialData), 33 },
                { typeof(global::Tech.Data.SkillData), 34 },
                { typeof(global::Tech.Data.UnitData), 35 },
                { typeof(global::Tech.Data.WeaponData), 36 },
                { typeof(global::Tech.DB.Ability), 37 },
                { typeof(global::Tech.DB.Enemy), 38 },
                { typeof(global::Tech.DB.Equipment), 39 },
                { typeof(global::Tech.DB.Item), 40 },
                { typeof(global::Tech.DB.Skill), 41 },
                { typeof(global::Tech.DB.TechMaterial), 42 },
                { typeof(global::Tech.DB.Unit), 43 },
                { typeof(global::Tech.DB.User), 44 },
                { typeof(global::Tech.DB.Weapon), 45 },
                { typeof(global::Tech.Network.Param.Player), 46 },
            };
        }

        internal static object GetFormatter(Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
                case 0: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.Data.EquipmentData>();
                case 1: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.Data.SkillData>();
                case 2: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.Equipment>();
                case 3: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.Item>();
                case 4: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.Skill>();
                case 5: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.TechMaterial>();
                case 6: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.Unit>();
                case 7: return new global::MessagePack.Formatters.ArrayFormatter<global::Tech.DB.Weapon>();
                case 8: return new MessagePack.Formatters.Tech.Data.DB.AilmentFormatter();
                case 9: return new MessagePack.Formatters.Tech.Data.DB.ElementFormatter();
                case 10: return new MessagePack.Formatters.Tech.Data.DB.EquipmentTypeFormatter();
                case 11: return new MessagePack.Formatters.Tech.Data.DB.ItemTypeFormatter();
                case 12: return new MessagePack.Formatters.Tech.Data.DB.ParameterTypeFormatter();
                case 13: return new MessagePack.Formatters.Tech.Data.DB.RaceTypeFormatter();
                case 14: return new MessagePack.Formatters.Tech.Data.DB.RarityFormatter();
                case 15: return new MessagePack.Formatters.Tech.Data.DB.TargetFormatter();
                case 16: return new MessagePack.Formatters.Tech.Data.DB.TargetStatFormatter();
                case 17: return new MessagePack.Formatters.Tech.Data.DB.TraitTypeFormatter();
                case 18: return new MessagePack.Formatters.Tech.Data.DB.UnitTypeFormatter();
                case 19: return new MessagePack.Formatters.Tech.Data.DB.WeaponTypeFormatter();
                case 20: return new MessagePack.Formatters.Tech.Data.AbilityDataFormatter();
                case 21: return new MessagePack.Formatters.Tech.Data.DB.AbilityInfoFormatter();
                case 22: return new MessagePack.Formatters.Tech.Data.DB.EnemyInfoFormatter();
                case 23: return new MessagePack.Formatters.Tech.Data.DB.EquipmentInfoFormatter();
                case 24: return new MessagePack.Formatters.Tech.Data.DB.ItemInfoFormatter();
                case 25: return new MessagePack.Formatters.Tech.Data.DB.MaterialInfoFormatter();
                case 26: return new MessagePack.Formatters.Tech.Data.DB.SkillInfoFormatter();
                case 27: return new MessagePack.Formatters.Tech.Data.DB.StatFormatter();
                case 28: return new MessagePack.Formatters.Tech.Data.DB.UnitInfoFormatter();
                case 29: return new MessagePack.Formatters.Tech.Data.DB.WeaponInfoFormatter();
                case 30: return new MessagePack.Formatters.Tech.Data.EnemyDataFormatter();
                case 31: return new MessagePack.Formatters.Tech.Data.EquipmentDataFormatter();
                case 32: return new MessagePack.Formatters.Tech.Data.ItemDataFormatter();
                case 33: return new MessagePack.Formatters.Tech.Data.MaterialDataFormatter();
                case 34: return new MessagePack.Formatters.Tech.Data.SkillDataFormatter();
                case 35: return new MessagePack.Formatters.Tech.Data.UnitDataFormatter();
                case 36: return new MessagePack.Formatters.Tech.Data.WeaponDataFormatter();
                case 37: return new MessagePack.Formatters.Tech.DB.AbilityFormatter();
                case 38: return new MessagePack.Formatters.Tech.DB.EnemyFormatter();
                case 39: return new MessagePack.Formatters.Tech.DB.EquipmentFormatter();
                case 40: return new MessagePack.Formatters.Tech.DB.ItemFormatter();
                case 41: return new MessagePack.Formatters.Tech.DB.SkillFormatter();
                case 42: return new MessagePack.Formatters.Tech.DB.TechMaterialFormatter();
                case 43: return new MessagePack.Formatters.Tech.DB.UnitFormatter();
                case 44: return new MessagePack.Formatters.Tech.DB.UserFormatter();
                case 45: return new MessagePack.Formatters.Tech.DB.WeaponFormatter();
                case 46: return new MessagePack.Formatters.Tech.Network.Param.PlayerFormatter();
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Tech.Data.DB
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class AilmentFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.Ailment>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.Ailment value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.Ailment Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.Ailment)reader.ReadInt32();
        }
    }

    public sealed class ElementFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.Element>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.Element value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.Element Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.Element)reader.ReadInt32();
        }
    }

    public sealed class EquipmentTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.EquipmentType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.EquipmentType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.EquipmentType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.EquipmentType)reader.ReadInt32();
        }
    }

    public sealed class ItemTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.ItemType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.ItemType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.ItemType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.ItemType)reader.ReadInt32();
        }
    }

    public sealed class ParameterTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.ParameterType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.ParameterType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.ParameterType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.ParameterType)reader.ReadInt32();
        }
    }

    public sealed class RaceTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.RaceType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.RaceType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.RaceType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.RaceType)reader.ReadInt32();
        }
    }

    public sealed class RarityFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.Rarity>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.Rarity value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.Rarity Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.Rarity)reader.ReadInt32();
        }
    }

    public sealed class TargetFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.Target>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.Target value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.Target Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.Target)reader.ReadInt32();
        }
    }

    public sealed class TargetStatFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.TargetStat>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.TargetStat value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.TargetStat Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.TargetStat)reader.ReadInt32();
        }
    }

    public sealed class TraitTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.TraitType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.TraitType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.TraitType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.TraitType)reader.ReadInt32();
        }
    }

    public sealed class UnitTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.UnitType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.UnitType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.UnitType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.UnitType)reader.ReadInt32();
        }
    }

    public sealed class WeaponTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.WeaponType>
    {
        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.WeaponType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Int32)value);
        }

        public global::Tech.Data.DB.WeaponType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::Tech.Data.DB.WeaponType)reader.ReadInt32();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name



// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.MagicOnion
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(20);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
            formatterResolver.GetFormatterWithVerify<T16>().Serialize(ref writer, value.Item16, options);
            formatterResolver.GetFormatterWithVerify<T17>().Serialize(ref writer, value.Item17, options);
            formatterResolver.GetFormatterWithVerify<T18>().Serialize(ref writer, value.Item18, options);
            formatterResolver.GetFormatterWithVerify<T19>().Serialize(ref writer, value.Item19, options);
            formatterResolver.GetFormatterWithVerify<T20>().Serialize(ref writer, value.Item20, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);
            var __Item16__ = default(T16);
            var __Item17__ = default(T17);
            var __Item18__ = default(T18);
            var __Item19__ = default(T19);
            var __Item20__ = default(T20);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Item16__ = formatterResolver.GetFormatterWithVerify<T16>().Deserialize(ref reader, options);
                        break;
                    case 16:
                        __Item17__ = formatterResolver.GetFormatterWithVerify<T17>().Deserialize(ref reader, options);
                        break;
                    case 17:
                        __Item18__ = formatterResolver.GetFormatterWithVerify<T18>().Deserialize(ref reader, options);
                        break;
                    case 18:
                        __Item19__ = formatterResolver.GetFormatterWithVerify<T19>().Deserialize(ref reader, options);
                        break;
                    case 19:
                        __Item20__ = formatterResolver.GetFormatterWithVerify<T20>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__, __Item16__, __Item17__, __Item18__, __Item19__, __Item20__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(19);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
            formatterResolver.GetFormatterWithVerify<T16>().Serialize(ref writer, value.Item16, options);
            formatterResolver.GetFormatterWithVerify<T17>().Serialize(ref writer, value.Item17, options);
            formatterResolver.GetFormatterWithVerify<T18>().Serialize(ref writer, value.Item18, options);
            formatterResolver.GetFormatterWithVerify<T19>().Serialize(ref writer, value.Item19, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);
            var __Item16__ = default(T16);
            var __Item17__ = default(T17);
            var __Item18__ = default(T18);
            var __Item19__ = default(T19);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Item16__ = formatterResolver.GetFormatterWithVerify<T16>().Deserialize(ref reader, options);
                        break;
                    case 16:
                        __Item17__ = formatterResolver.GetFormatterWithVerify<T17>().Deserialize(ref reader, options);
                        break;
                    case 17:
                        __Item18__ = formatterResolver.GetFormatterWithVerify<T18>().Deserialize(ref reader, options);
                        break;
                    case 18:
                        __Item19__ = formatterResolver.GetFormatterWithVerify<T19>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__, __Item16__, __Item17__, __Item18__, __Item19__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(18);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
            formatterResolver.GetFormatterWithVerify<T16>().Serialize(ref writer, value.Item16, options);
            formatterResolver.GetFormatterWithVerify<T17>().Serialize(ref writer, value.Item17, options);
            formatterResolver.GetFormatterWithVerify<T18>().Serialize(ref writer, value.Item18, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);
            var __Item16__ = default(T16);
            var __Item17__ = default(T17);
            var __Item18__ = default(T18);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Item16__ = formatterResolver.GetFormatterWithVerify<T16>().Deserialize(ref reader, options);
                        break;
                    case 16:
                        __Item17__ = formatterResolver.GetFormatterWithVerify<T17>().Deserialize(ref reader, options);
                        break;
                    case 17:
                        __Item18__ = formatterResolver.GetFormatterWithVerify<T18>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__, __Item16__, __Item17__, __Item18__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(17);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
            formatterResolver.GetFormatterWithVerify<T16>().Serialize(ref writer, value.Item16, options);
            formatterResolver.GetFormatterWithVerify<T17>().Serialize(ref writer, value.Item17, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);
            var __Item16__ = default(T16);
            var __Item17__ = default(T17);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Item16__ = formatterResolver.GetFormatterWithVerify<T16>().Deserialize(ref reader, options);
                        break;
                    case 16:
                        __Item17__ = formatterResolver.GetFormatterWithVerify<T17>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__, __Item16__, __Item17__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(16);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
            formatterResolver.GetFormatterWithVerify<T16>().Serialize(ref writer, value.Item16, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);
            var __Item16__ = default(T16);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    case 15:
                        __Item16__ = formatterResolver.GetFormatterWithVerify<T16>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__, __Item16__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(15);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
            formatterResolver.GetFormatterWithVerify<T15>().Serialize(ref writer, value.Item15, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);
            var __Item15__ = default(T15);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    case 14:
                        __Item15__ = formatterResolver.GetFormatterWithVerify<T15>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__, __Item15__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(14);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
            formatterResolver.GetFormatterWithVerify<T14>().Serialize(ref writer, value.Item14, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);
            var __Item14__ = default(T14);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    case 13:
                        __Item14__ = formatterResolver.GetFormatterWithVerify<T14>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__, __Item14__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(13);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
            formatterResolver.GetFormatterWithVerify<T13>().Serialize(ref writer, value.Item13, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);
            var __Item13__ = default(T13);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __Item13__ = formatterResolver.GetFormatterWithVerify<T13>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__, __Item13__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(12);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
            formatterResolver.GetFormatterWithVerify<T12>().Serialize(ref writer, value.Item12, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);
            var __Item12__ = default(T12);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __Item12__ = formatterResolver.GetFormatterWithVerify<T12>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__, __Item12__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(11);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
            formatterResolver.GetFormatterWithVerify<T11>().Serialize(ref writer, value.Item11, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);
            var __Item11__ = default(T11);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Item11__ = formatterResolver.GetFormatterWithVerify<T11>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__, __Item11__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(10);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
            formatterResolver.GetFormatterWithVerify<T10>().Serialize(ref writer, value.Item10, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);
            var __Item10__ = default(T10);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Item10__ = formatterResolver.GetFormatterWithVerify<T10>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__, __Item10__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8,T9> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(9);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
            formatterResolver.GetFormatterWithVerify<T9>().Serialize(ref writer, value.Item9, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);
            var __Item9__ = default(T9);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Item9__ = formatterResolver.GetFormatterWithVerify<T9>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__, __Item9__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7,T8> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(8);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            formatterResolver.GetFormatterWithVerify<T8>().Serialize(ref writer, value.Item8, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);
            var __Item8__ = default(T8);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Item8__ = formatterResolver.GetFormatterWithVerify<T8>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7, T8>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__, __Item8__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6,T7> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(7);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            formatterResolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);
            var __Item7__ = default(T7);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Item7__ = formatterResolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6, T7>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__, __Item7__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5,T6> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(6);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            formatterResolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);
            var __Item6__ = default(T6);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Item6__ = formatterResolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5, T6>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__, __Item6__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4,T5> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(5);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            formatterResolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);
            var __Item5__ = default(T5);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Item5__ = formatterResolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4, T5>(__Item1__, __Item2__, __Item3__, __Item4__, __Item5__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3,T4> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            formatterResolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);
            var __Item4__ = default(T4);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Item4__ = formatterResolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3, T4>(__Item1__, __Item2__, __Item3__, __Item4__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2,T3> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2, T3>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2, T3> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(3);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            formatterResolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);
            var __Item3__ = default(T3);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Item3__ = formatterResolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2, T3>(__Item1__, __Item2__, __Item3__);
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class DynamicArgumentTupleFormatter<T1,T2> : global::MessagePack.Formatters.IMessagePackFormatter<global::MagicOnion.DynamicArgumentTuple<T1, T2>>
    {


        public void Serialize(ref MessagePackWriter writer, global::MagicOnion.DynamicArgumentTuple<T1, T2> value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            formatterResolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
        }

        public global::MagicOnion.DynamicArgumentTuple<T1, T2> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Item1__ = default(T1);
            var __Item2__ = default(T2);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Item1__ = formatterResolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Item2__ = formatterResolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::MagicOnion.DynamicArgumentTuple<T1, T2>(__Item1__, __Item2__);
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Tech.Data
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class AbilityDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.AbilityData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public AbilityDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "innocentCost", 2 },
                { "description", 3 },
                { "abilityDescription", 4 },
                { "image", 5 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("innocentCost"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("abilityDescription"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.AbilityData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(6);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            writer.Write(value.innocentCost);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.abilityDescription, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
        }

        public global::Tech.Data.AbilityData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __innocentCost__ = default(int);
            var __description__ = default(string);
            var __abilityDescription__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __innocentCost__ = reader.ReadInt32();
                        break;
                    case 3:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __abilityDescription__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.AbilityData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.innocentCost = __innocentCost__;
            ____result.description = __description__;
            ____result.abilityDescription = __abilityDescription__;
            ____result.image = __image__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EnemyDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.EnemyData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EnemyDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "description", 2 },
                { "image", 3 },
                { "weaponData", 4 },
                { "equipmentDatas", 5 },
                { "abilityData", 6 },
                { "skillDatas", 7 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("weaponData"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("equipmentDatas"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("abilityData"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("skillDatas"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.EnemyData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(8);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.WeaponData>().Serialize(ref writer, value.weaponData, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.EquipmentData[]>().Serialize(ref writer, value.equipmentDatas, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.AbilityData>().Serialize(ref writer, value.abilityData, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.SkillData[]>().Serialize(ref writer, value.skillDatas, options);
        }

        public global::Tech.Data.EnemyData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);
            var __weaponData__ = default(global::Tech.Data.WeaponData);
            var __equipmentDatas__ = default(global::Tech.Data.EquipmentData[]);
            var __abilityData__ = default(global::Tech.Data.AbilityData);
            var __skillDatas__ = default(global::Tech.Data.SkillData[]);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __weaponData__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.WeaponData>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __equipmentDatas__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.EquipmentData[]>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __abilityData__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.AbilityData>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __skillDatas__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.SkillData[]>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.EnemyData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            ____result.weaponData = __weaponData__;
            ____result.equipmentDatas = __equipmentDatas__;
            ____result.abilityData = __abilityData__;
            ____result.skillDatas = __skillDatas__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EquipmentDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.EquipmentData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EquipmentDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "description", 2 },
                { "image", 3 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.EquipmentData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(4);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
        }

        public global::Tech.Data.EquipmentData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.EquipmentData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ItemDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.ItemData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public ItemDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "description", 2 },
                { "image", 3 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.ItemData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(4);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
        }

        public global::Tech.Data.ItemData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.ItemData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class MaterialDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.MaterialData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public MaterialDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "description", 2 },
                { "image", 3 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.MaterialData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(4);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
        }

        public global::Tech.Data.MaterialData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.MaterialData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SkillDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.SkillData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public SkillDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "image", 2 },
                { "description", 3 },
                { "skillDescription", 4 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("skillDescription"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.SkillData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(5);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.skillDescription, options);
        }

        public global::Tech.Data.SkillData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);
            var __description__ = default(string);
            var __skillDescription__ = default(string);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __skillDescription__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.SkillData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.image = __image__;
            ____result.description = __description__;
            ____result.skillDescription = __skillDescription__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UnitDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.UnitData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public UnitDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "name", 0 },
                { "description", 1 },
                { "image", 2 },
                { "weaponData", 3 },
                { "equipmentDatas", 4 },
                { "abilityData", 5 },
                { "skillDatas", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("weaponData"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("equipmentDatas"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("abilityData"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("skillDatas"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.UnitData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.WeaponData>().Serialize(ref writer, value.weaponData, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.EquipmentData[]>().Serialize(ref writer, value.equipmentDatas, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.AbilityData>().Serialize(ref writer, value.abilityData, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.SkillData[]>().Serialize(ref writer, value.skillDatas, options);
        }

        public global::Tech.Data.UnitData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);
            var __weaponData__ = default(global::Tech.Data.WeaponData);
            var __equipmentDatas__ = default(global::Tech.Data.EquipmentData[]);
            var __abilityData__ = default(global::Tech.Data.AbilityData);
            var __skillDatas__ = default(global::Tech.Data.SkillData[]);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __weaponData__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.WeaponData>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __equipmentDatas__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.EquipmentData[]>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __abilityData__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.AbilityData>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __skillDatas__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.SkillData[]>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.UnitData();
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            ____result.weaponData = __weaponData__;
            ____result.equipmentDatas = __equipmentDatas__;
            ____result.abilityData = __abilityData__;
            ____result.skillDatas = __skillDatas__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class WeaponDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.WeaponData>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public WeaponDataFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "id", 0 },
                { "name", 1 },
                { "description", 2 },
                { "image", 3 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("image"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.WeaponData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(4);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.description, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Serialize(ref writer, value.image, options);
        }

        public global::Tech.Data.WeaponData Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __id__ = default(byte[]);
            var __name__ = default(string);
            var __description__ = default(string);
            var __image__ = default(global::UnityEngine.Texture2D);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __image__ = formatterResolver.GetFormatterWithVerify<global::UnityEngine.Texture2D>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.WeaponData();
            ____result.id = __id__;
            ____result.name = __name__;
            ____result.description = __description__;
            ____result.image = __image__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Tech.Data.DB
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class AbilityInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.AbilityInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public AbilityInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "ElementType", 0 },
                { "TargetParameter", 1 },
                { "AbilityType", 2 },
                { "AbilityTarget", 3 },
                { "Ailment", 4 },
                { "NumberOfHits", 5 },
                { "Duration", 6 },
                { "Amount", 7 },
                { "Buff", 8 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("TargetParameter"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("AbilityType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("AbilityTarget"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Ailment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("NumberOfHits"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Duration"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Amount"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Buff"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.AbilityInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(9);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementType, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TargetStat>().Serialize(ref writer, value.TargetParameter, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ParameterType>().Serialize(ref writer, value.AbilityType, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Serialize(ref writer, value.AbilityTarget, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.Ailment, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            writer.Write(value.NumberOfHits);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Duration);
            writer.WriteRaw(this.____stringByteKeys[7]);
            writer.Write(value.Amount);
            writer.WriteRaw(this.____stringByteKeys[8]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.Buff, options);
        }

        public global::Tech.Data.DB.AbilityInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __ElementType__ = default(global::Tech.Data.DB.Element);
            var __TargetParameter__ = default(global::Tech.Data.DB.TargetStat);
            var __AbilityType__ = default(global::Tech.Data.DB.ParameterType);
            var __AbilityTarget__ = default(global::Tech.Data.DB.Target);
            var __Ailment__ = default(global::Tech.Data.DB.Ailment);
            var __NumberOfHits__ = default(int);
            var __Duration__ = default(int);
            var __Amount__ = default(int);
            var __Buff__ = default(global::Tech.Data.DB.Stat);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __ElementType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __TargetParameter__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TargetStat>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __AbilityType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ParameterType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __AbilityTarget__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Ailment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __NumberOfHits__ = reader.ReadInt32();
                        break;
                    case 6:
                        __Duration__ = reader.ReadInt32();
                        break;
                    case 7:
                        __Amount__ = reader.ReadInt32();
                        break;
                    case 8:
                        __Buff__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.AbilityInfo();
            ____result.ElementType = __ElementType__;
            ____result.TargetParameter = __TargetParameter__;
            ____result.AbilityType = __AbilityType__;
            ____result.AbilityTarget = __AbilityTarget__;
            ____result.Ailment = __Ailment__;
            ____result.NumberOfHits = __NumberOfHits__;
            ____result.Duration = __Duration__;
            ____result.Amount = __Amount__;
            ____result.Buff = __Buff__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EnemyInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.EnemyInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EnemyInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Rarity", 0 },
                { "Level", 1 },
                { "RaceType", 2 },
                { "ElementAttack", 3 },
                { "ElementResistance", 4 },
                { "StatusAilmentResistance", 5 },
                { "Stat", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("RaceType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementAttack"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementResistance"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("StatusAilmentResistance"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Stat"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.EnemyInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.RaceType>().Serialize(ref writer, value.RaceType, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementAttack, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementResistance, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.StatusAilmentResistance, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.Stat, options);
        }

        public global::Tech.Data.DB.EnemyInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);
            var __Level__ = default(int);
            var __RaceType__ = default(global::Tech.Data.DB.RaceType);
            var __ElementAttack__ = default(global::Tech.Data.DB.Element);
            var __ElementResistance__ = default(global::Tech.Data.DB.Element);
            var __StatusAilmentResistance__ = default(global::Tech.Data.DB.Ailment);
            var __Stat__ = default(global::Tech.Data.DB.Stat);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 2:
                        __RaceType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.RaceType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __ElementAttack__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ElementResistance__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __StatusAilmentResistance__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Stat__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.EnemyInfo();
            ____result.Rarity = __Rarity__;
            ____result.Level = __Level__;
            ____result.RaceType = __RaceType__;
            ____result.ElementAttack = __ElementAttack__;
            ____result.ElementResistance = __ElementResistance__;
            ____result.StatusAilmentResistance = __StatusAilmentResistance__;
            ____result.Stat = __Stat__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EquipmentInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.EquipmentInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EquipmentInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Level", 0 },
                { "Rarity", 1 },
                { "EquipmentType", 2 },
                { "EquipmentStat", 3 },
                { "ElementalAttack", 4 },
                { "StatusAilment", 5 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("EquipmentType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("EquipmentStat"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementalAttack"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("StatusAilment"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.EquipmentInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(6);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EquipmentType>().Serialize(ref writer, value.EquipmentType, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.EquipmentStat, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementalAttack, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.StatusAilment, options);
        }

        public global::Tech.Data.DB.EquipmentInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Level__ = default(int);
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);
            var __EquipmentType__ = default(global::Tech.Data.DB.EquipmentType);
            var __EquipmentStat__ = default(global::Tech.Data.DB.Stat);
            var __ElementalAttack__ = default(global::Tech.Data.DB.Element);
            var __StatusAilment__ = default(global::Tech.Data.DB.Ailment);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __EquipmentType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EquipmentType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __EquipmentStat__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ElementalAttack__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __StatusAilment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.EquipmentInfo();
            ____result.Level = __Level__;
            ____result.Rarity = __Rarity__;
            ____result.EquipmentType = __EquipmentType__;
            ____result.EquipmentStat = __EquipmentStat__;
            ____result.ElementalAttack = __ElementalAttack__;
            ____result.StatusAilment = __StatusAilment__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ItemInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.ItemInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public ItemInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Level", 0 },
                { "Rarity", 1 },
                { "ItemType", 2 },
                { "CureAilment", 3 },
                { "InflictAilment", 4 },
                { "Target", 5 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ItemType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("CureAilment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("InflictAilment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Target"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.ItemInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(6);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ItemType>().Serialize(ref writer, value.ItemType, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.CureAilment, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.InflictAilment, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Serialize(ref writer, value.Target, options);
        }

        public global::Tech.Data.DB.ItemInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Level__ = default(int);
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);
            var __ItemType__ = default(global::Tech.Data.DB.ItemType);
            var __CureAilment__ = default(global::Tech.Data.DB.Ailment);
            var __InflictAilment__ = default(global::Tech.Data.DB.Ailment);
            var __Target__ = default(global::Tech.Data.DB.Target);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __ItemType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ItemType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __CureAilment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __InflictAilment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Target__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.ItemInfo();
            ____result.Level = __Level__;
            ____result.Rarity = __Rarity__;
            ____result.ItemType = __ItemType__;
            ____result.CureAilment = __CureAilment__;
            ____result.InflictAilment = __InflictAilment__;
            ____result.Target = __Target__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class MaterialInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.MaterialInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public MaterialInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Level", 0 },
                { "Rarity", 1 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.MaterialInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(2);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
        }

        public global::Tech.Data.DB.MaterialInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Level__ = default(int);
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.MaterialInfo();
            ____result.Level = __Level__;
            ____result.Rarity = __Rarity__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SkillInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.SkillInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public SkillInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "ElementType", 0 },
                { "TraitType", 1 },
                { "TargetParameter", 2 },
                { "SkillType", 3 },
                { "SkillTarget", 4 },
                { "Ailment", 5 },
                { "ManapointCost", 6 },
                { "NumberOfHits", 7 },
                { "Duration", 8 },
                { "Amount", 9 },
                { "Buff", 10 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("TraitType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("TargetParameter"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("SkillType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("SkillTarget"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Ailment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ManapointCost"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("NumberOfHits"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Duration"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Amount"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Buff"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.SkillInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(11);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementType, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TraitType>().Serialize(ref writer, value.TraitType, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TargetStat>().Serialize(ref writer, value.TargetParameter, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ParameterType>().Serialize(ref writer, value.SkillType, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Serialize(ref writer, value.SkillTarget, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.Ailment, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.ManapointCost);
            writer.WriteRaw(this.____stringByteKeys[7]);
            writer.Write(value.NumberOfHits);
            writer.WriteRaw(this.____stringByteKeys[8]);
            writer.Write(value.Duration);
            writer.WriteRaw(this.____stringByteKeys[9]);
            writer.Write(value.Amount);
            writer.WriteRaw(this.____stringByteKeys[10]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.Buff, options);
        }

        public global::Tech.Data.DB.SkillInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __ElementType__ = default(global::Tech.Data.DB.Element);
            var __TraitType__ = default(global::Tech.Data.DB.TraitType);
            var __TargetParameter__ = default(global::Tech.Data.DB.TargetStat);
            var __SkillType__ = default(global::Tech.Data.DB.ParameterType);
            var __SkillTarget__ = default(global::Tech.Data.DB.Target);
            var __Ailment__ = default(global::Tech.Data.DB.Ailment);
            var __ManapointCost__ = default(int);
            var __NumberOfHits__ = default(int);
            var __Duration__ = default(int);
            var __Amount__ = default(int);
            var __Buff__ = default(global::Tech.Data.DB.Stat);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __ElementType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __TraitType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TraitType>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __TargetParameter__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.TargetStat>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __SkillType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ParameterType>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __SkillTarget__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Target>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __Ailment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __ManapointCost__ = reader.ReadInt32();
                        break;
                    case 7:
                        __NumberOfHits__ = reader.ReadInt32();
                        break;
                    case 8:
                        __Duration__ = reader.ReadInt32();
                        break;
                    case 9:
                        __Amount__ = reader.ReadInt32();
                        break;
                    case 10:
                        __Buff__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.SkillInfo();
            ____result.ElementType = __ElementType__;
            ____result.TraitType = __TraitType__;
            ____result.TargetParameter = __TargetParameter__;
            ____result.SkillType = __SkillType__;
            ____result.SkillTarget = __SkillTarget__;
            ____result.Ailment = __Ailment__;
            ____result.ManapointCost = __ManapointCost__;
            ____result.NumberOfHits = __NumberOfHits__;
            ____result.Duration = __Duration__;
            ____result.Amount = __Amount__;
            ____result.Buff = __Buff__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class StatFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.Stat>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public StatFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Health", 0 },
                { "Attack", 1 },
                { "Defence", 2 },
                { "Manapoint", 3 },
                { "Magic", 4 },
                { "Spirit", 5 },
                { "Speed", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Health"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Attack"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Defence"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Manapoint"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Magic"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Spirit"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Speed"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.Stat value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Health);
            writer.WriteRaw(this.____stringByteKeys[1]);
            writer.Write(value.Attack);
            writer.WriteRaw(this.____stringByteKeys[2]);
            writer.Write(value.Defence);
            writer.WriteRaw(this.____stringByteKeys[3]);
            writer.Write(value.Manapoint);
            writer.WriteRaw(this.____stringByteKeys[4]);
            writer.Write(value.Magic);
            writer.WriteRaw(this.____stringByteKeys[5]);
            writer.Write(value.Spirit);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Speed);
        }

        public global::Tech.Data.DB.Stat Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Health__ = default(int);
            var __Attack__ = default(int);
            var __Defence__ = default(int);
            var __Manapoint__ = default(int);
            var __Magic__ = default(int);
            var __Spirit__ = default(int);
            var __Speed__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Health__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Attack__ = reader.ReadInt32();
                        break;
                    case 2:
                        __Defence__ = reader.ReadInt32();
                        break;
                    case 3:
                        __Manapoint__ = reader.ReadInt32();
                        break;
                    case 4:
                        __Magic__ = reader.ReadInt32();
                        break;
                    case 5:
                        __Spirit__ = reader.ReadInt32();
                        break;
                    case 6:
                        __Speed__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.Stat();
            ____result.Health = __Health__;
            ____result.Attack = __Attack__;
            ____result.Defence = __Defence__;
            ____result.Manapoint = __Manapoint__;
            ____result.Magic = __Magic__;
            ____result.Spirit = __Spirit__;
            ____result.Speed = __Speed__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UnitInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.UnitInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public UnitInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Level", 0 },
                { "Rarity", 1 },
                { "Stat", 2 },
                { "RaceType", 3 },
                { "ElementAttack", 4 },
                { "ElementResistance", 5 },
                { "StatusAilmentResistance", 6 },
                { "WeaponCompatibility", 7 },
                { "UnitType", 8 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Stat"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("RaceType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementAttack"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementResistance"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("StatusAilmentResistance"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("WeaponCompatibility"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("UnitType"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.UnitInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(9);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.Stat, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.RaceType>().Serialize(ref writer, value.RaceType, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementAttack, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementResistance, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.StatusAilmentResistance, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponType>().Serialize(ref writer, value.WeaponCompatibility, options);
            writer.WriteRaw(this.____stringByteKeys[8]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.UnitType>().Serialize(ref writer, value.UnitType, options);
        }

        public global::Tech.Data.DB.UnitInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Level__ = default(int);
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);
            var __Stat__ = default(global::Tech.Data.DB.Stat);
            var __RaceType__ = default(global::Tech.Data.DB.RaceType);
            var __ElementAttack__ = default(global::Tech.Data.DB.Element);
            var __ElementResistance__ = default(global::Tech.Data.DB.Element);
            var __StatusAilmentResistance__ = default(global::Tech.Data.DB.Ailment);
            var __WeaponCompatibility__ = default(global::Tech.Data.DB.WeaponType);
            var __UnitType__ = default(global::Tech.Data.DB.UnitType);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Stat__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __RaceType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.RaceType>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ElementAttack__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ElementResistance__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __StatusAilmentResistance__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __WeaponCompatibility__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponType>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __UnitType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.UnitType>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.UnitInfo();
            ____result.Level = __Level__;
            ____result.Rarity = __Rarity__;
            ____result.Stat = __Stat__;
            ____result.RaceType = __RaceType__;
            ____result.ElementAttack = __ElementAttack__;
            ____result.ElementResistance = __ElementResistance__;
            ____result.StatusAilmentResistance = __StatusAilmentResistance__;
            ____result.WeaponCompatibility = __WeaponCompatibility__;
            ____result.UnitType = __UnitType__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class WeaponInfoFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Data.DB.WeaponInfo>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public WeaponInfoFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Level", 0 },
                { "Rarity", 1 },
                { "WeaponType", 2 },
                { "WeaponStat", 3 },
                { "ElementAttack", 4 },
                { "StatusAliment", 5 },
                { "NumberOfAttack", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Rarity"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("WeaponType"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("WeaponStat"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ElementAttack"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("StatusAliment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("NumberOfAttack"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.Data.DB.WeaponInfo value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Serialize(ref writer, value.Rarity, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponType>().Serialize(ref writer, value.WeaponType, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Serialize(ref writer, value.WeaponStat, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Serialize(ref writer, value.ElementAttack, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Serialize(ref writer, value.StatusAliment, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.NumberOfAttack);
        }

        public global::Tech.Data.DB.WeaponInfo Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Level__ = default(int);
            var __Rarity__ = default(global::Tech.Data.DB.Rarity);
            var __WeaponType__ = default(global::Tech.Data.DB.WeaponType);
            var __WeaponStat__ = default(global::Tech.Data.DB.Stat);
            var __ElementAttack__ = default(global::Tech.Data.DB.Element);
            var __StatusAliment__ = default(global::Tech.Data.DB.Ailment);
            var __NumberOfAttack__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 1:
                        __Rarity__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Rarity>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __WeaponType__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponType>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __WeaponStat__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Stat>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ElementAttack__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Element>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __StatusAliment__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.Ailment>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __NumberOfAttack__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Data.DB.WeaponInfo();
            ____result.Level = __Level__;
            ____result.Rarity = __Rarity__;
            ____result.WeaponType = __WeaponType__;
            ____result.WeaponStat = __WeaponStat__;
            ____result.ElementAttack = __ElementAttack__;
            ____result.StatusAliment = __StatusAliment__;
            ____result.NumberOfAttack = __NumberOfAttack__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Tech.DB
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class AbilityFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Ability>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public AbilityFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "InnocenceCost", 2 },
                { "Address", 3 },
                { "Description", 4 },
                { "AbilityDescription", 5 },
                { "ImageBytes", 6 },
                { "AbilityInfo", 7 },
                { "Index", 8 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("InnocenceCost"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("AbilityDescription"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("AbilityInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Ability value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(9);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            writer.Write(value.InnocenceCost);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.AbilityDescription, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.AbilityInfo>().Serialize(ref writer, value.AbilityInfo, options);
            writer.WriteRaw(this.____stringByteKeys[8]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.Ability Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __InnocenceCost__ = default(int);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __AbilityDescription__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __AbilityInfo__ = default(global::Tech.Data.DB.AbilityInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __InnocenceCost__ = reader.ReadInt32();
                        break;
                    case 3:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __AbilityDescription__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __AbilityInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.AbilityInfo>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Ability();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.InnocenceCost = __InnocenceCost__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.AbilityDescription = __AbilityDescription__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.AbilityInfo = __AbilityInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EnemyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Enemy>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EnemyFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Index", 2 },
                { "Address", 3 },
                { "Description", 4 },
                { "ImageBytes", 5 },
                { "EnemyInfo", 6 },
                { "Weapon", 7 },
                { "Equipment", 8 },
                { "Ability", 9 },
                { "Skills", 10 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("EnemyInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Weapon"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Equipment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Ability"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Skills"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Enemy value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(11);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            writer.Write(value.Index);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EnemyInfo>().Serialize(ref writer, value.EnemyInfo, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon>().Serialize(ref writer, value.Weapon, options);
            writer.WriteRaw(this.____stringByteKeys[8]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Serialize(ref writer, value.Equipment, options);
            writer.WriteRaw(this.____stringByteKeys[9]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Ability>().Serialize(ref writer, value.Ability, options);
            writer.WriteRaw(this.____stringByteKeys[10]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Skill[]>().Serialize(ref writer, value.Skills, options);
        }

        public global::Tech.DB.Enemy Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Index__ = default(int);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __EnemyInfo__ = default(global::Tech.Data.DB.EnemyInfo);
            var __Weapon__ = default(global::Tech.DB.Weapon);
            var __Equipment__ = default(global::Tech.DB.Equipment[]);
            var __Ability__ = default(global::Tech.DB.Ability);
            var __Skills__ = default(global::Tech.DB.Skill[]);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Index__ = reader.ReadInt32();
                        break;
                    case 3:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __EnemyInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EnemyInfo>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Weapon__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Equipment__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Ability__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Ability>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Skills__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Skill[]>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Enemy();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Index = __Index__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.EnemyInfo = __EnemyInfo__;
            ____result.Weapon = __Weapon__;
            ____result.Equipment = __Equipment__;
            ____result.Ability = __Ability__;
            ____result.Skills = __Skills__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class EquipmentFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Equipment>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public EquipmentFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Address", 2 },
                { "Description", 3 },
                { "ImageBytes", 4 },
                { "EquipmentInfo", 5 },
                { "Index", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("EquipmentInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Equipment value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EquipmentInfo>().Serialize(ref writer, value.EquipmentInfo, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.Equipment Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __EquipmentInfo__ = default(global::Tech.Data.DB.EquipmentInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __EquipmentInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.EquipmentInfo>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Equipment();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.EquipmentInfo = __EquipmentInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ItemFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Item>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public ItemFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Address", 2 },
                { "Description", 3 },
                { "ImageBytes", 4 },
                { "ItemInfo", 5 },
                { "Index", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ItemInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Item value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ItemInfo>().Serialize(ref writer, value.ItemInfo, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.Item Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __ItemInfo__ = default(global::Tech.Data.DB.ItemInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ItemInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.ItemInfo>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Item();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.ItemInfo = __ItemInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class SkillFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Skill>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public SkillFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Address", 2 },
                { "Description", 3 },
                { "SkillDescription", 4 },
                { "ImageBytes", 5 },
                { "SkillInfo", 6 },
                { "Index", 7 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("SkillDescription"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("SkillInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Skill value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(8);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.SkillDescription, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.SkillInfo>().Serialize(ref writer, value.SkillInfo, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.Skill Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __SkillDescription__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __SkillInfo__ = default(global::Tech.Data.DB.SkillInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __SkillDescription__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __SkillInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.SkillInfo>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Skill();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.SkillDescription = __SkillDescription__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.SkillInfo = __SkillInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class TechMaterialFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.TechMaterial>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public TechMaterialFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Address", 2 },
                { "Description", 3 },
                { "ImageBytes", 4 },
                { "MaterialInfo", 5 },
                { "Index", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("MaterialInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.TechMaterial value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.MaterialInfo>().Serialize(ref writer, value.MaterialInfo, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.TechMaterial Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __MaterialInfo__ = default(global::Tech.Data.DB.MaterialInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __MaterialInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.MaterialInfo>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.TechMaterial();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.MaterialInfo = __MaterialInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UnitFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Unit>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public UnitFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Index", 2 },
                { "Address", 3 },
                { "Description", 4 },
                { "ImageBytes", 5 },
                { "CharacterInfo", 6 },
                { "Weapon", 7 },
                { "Equipment", 8 },
                { "Ability", 9 },
                { "Skills", 10 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("CharacterInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Weapon"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Equipment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Ability"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Skills"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Unit value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(11);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            writer.Write(value.Index);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.UnitInfo>().Serialize(ref writer, value.CharacterInfo, options);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon>().Serialize(ref writer, value.Weapon, options);
            writer.WriteRaw(this.____stringByteKeys[8]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Serialize(ref writer, value.Equipment, options);
            writer.WriteRaw(this.____stringByteKeys[9]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Ability>().Serialize(ref writer, value.Ability, options);
            writer.WriteRaw(this.____stringByteKeys[10]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Skill[]>().Serialize(ref writer, value.Skills, options);
        }

        public global::Tech.DB.Unit Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Index__ = default(int);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __CharacterInfo__ = default(global::Tech.Data.DB.UnitInfo);
            var __Weapon__ = default(global::Tech.DB.Weapon);
            var __Equipment__ = default(global::Tech.DB.Equipment[]);
            var __Ability__ = default(global::Tech.DB.Ability);
            var __Skills__ = default(global::Tech.DB.Skill[]);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Index__ = reader.ReadInt32();
                        break;
                    case 3:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __CharacterInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.UnitInfo>().Deserialize(ref reader, options);
                        break;
                    case 7:
                        __Weapon__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __Equipment__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __Ability__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Ability>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __Skills__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Skill[]>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Unit();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Index = __Index__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.CharacterInfo = __CharacterInfo__;
            ____result.Weapon = __Weapon__;
            ____result.Equipment = __Equipment__;
            ____result.Ability = __Ability__;
            ____result.Skills = __Skills__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class UserFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.User>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public UserFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Level", 1 },
                { "Username", 2 },
                { "TrophyTextureImage", 3 },
                { "Note", 4 },
                { "Cred", 5 },
                { "Energy", 6 },
                { "Comment", 7 },
                { "PossessedUnit", 8 },
                { "PossessedEquipments", 9 },
                { "PossessedMaterials", 10 },
                { "PossessedItems", 11 },
                { "PossessedWeapons", 12 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Level"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Username"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("TrophyTextureImage"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Note"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Cred"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Energy"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Comment"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("PossessedUnit"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("PossessedEquipments"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("PossessedMaterials"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("PossessedItems"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("PossessedWeapons"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.User value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(13);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            writer.Write(value.Level);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Username, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.TrophyTextureImage, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            writer.Write(value.Note);
            writer.WriteRaw(this.____stringByteKeys[5]);
            writer.Write(value.Cred);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Energy);
            writer.WriteRaw(this.____stringByteKeys[7]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Comment, options);
            writer.WriteRaw(this.____stringByteKeys[8]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Unit[]>().Serialize(ref writer, value.PossessedUnit, options);
            writer.WriteRaw(this.____stringByteKeys[9]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Serialize(ref writer, value.PossessedEquipments, options);
            writer.WriteRaw(this.____stringByteKeys[10]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.TechMaterial[]>().Serialize(ref writer, value.PossessedMaterials, options);
            writer.WriteRaw(this.____stringByteKeys[11]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Item[]>().Serialize(ref writer, value.PossessedItems, options);
            writer.WriteRaw(this.____stringByteKeys[12]);
            formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon[]>().Serialize(ref writer, value.PossessedWeapons, options);
        }

        public global::Tech.DB.User Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Level__ = default(int);
            var __Username__ = default(string);
            var __TrophyTextureImage__ = default(byte[]);
            var __Note__ = default(int);
            var __Cred__ = default(int);
            var __Energy__ = default(int);
            var __Comment__ = default(string);
            var __PossessedUnit__ = default(global::Tech.DB.Unit[]);
            var __PossessedEquipments__ = default(global::Tech.DB.Equipment[]);
            var __PossessedMaterials__ = default(global::Tech.DB.TechMaterial[]);
            var __PossessedItems__ = default(global::Tech.DB.Item[]);
            var __PossessedWeapons__ = default(global::Tech.DB.Weapon[]);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Level__ = reader.ReadInt32();
                        break;
                    case 2:
                        __Username__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __TrophyTextureImage__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __Note__ = reader.ReadInt32();
                        break;
                    case 5:
                        __Cred__ = reader.ReadInt32();
                        break;
                    case 6:
                        __Energy__ = reader.ReadInt32();
                        break;
                    case 7:
                        __Comment__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 8:
                        __PossessedUnit__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Unit[]>().Deserialize(ref reader, options);
                        break;
                    case 9:
                        __PossessedEquipments__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Equipment[]>().Deserialize(ref reader, options);
                        break;
                    case 10:
                        __PossessedMaterials__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.TechMaterial[]>().Deserialize(ref reader, options);
                        break;
                    case 11:
                        __PossessedItems__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Item[]>().Deserialize(ref reader, options);
                        break;
                    case 12:
                        __PossessedWeapons__ = formatterResolver.GetFormatterWithVerify<global::Tech.DB.Weapon[]>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.User();
            ____result.Id = __Id__;
            ____result.Level = __Level__;
            ____result.Username = __Username__;
            ____result.TrophyTextureImage = __TrophyTextureImage__;
            ____result.Note = __Note__;
            ____result.Cred = __Cred__;
            ____result.Energy = __Energy__;
            ____result.Comment = __Comment__;
            ____result.PossessedUnit = __PossessedUnit__;
            ____result.PossessedEquipments = __PossessedEquipments__;
            ____result.PossessedMaterials = __PossessedMaterials__;
            ____result.PossessedItems = __PossessedItems__;
            ____result.PossessedWeapons = __PossessedWeapons__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class WeaponFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.DB.Weapon>
    {


        private readonly global::MessagePack.Internal.AutomataDictionary ____keyMapping;
        private readonly byte[][] ____stringByteKeys;

        public WeaponFormatter()
        {
            this.____keyMapping = new global::MessagePack.Internal.AutomataDictionary()
            {
                { "Id", 0 },
                { "Name", 1 },
                { "Address", 2 },
                { "Description", 3 },
                { "ImageBytes", 4 },
                { "WeaponInfo", 5 },
                { "Index", 6 },
            };

            this.____stringByteKeys = new byte[][]
            {
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Id"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Name"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Address"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Description"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("ImageBytes"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("WeaponInfo"),
                global::MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes("Index"),
            };
        }

        public void Serialize(ref MessagePackWriter writer, global::Tech.DB.Weapon value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            value.OnBeforeSerialize();
            writer.WriteMapHeader(7);
            writer.WriteRaw(this.____stringByteKeys[0]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.Id, options);
            writer.WriteRaw(this.____stringByteKeys[1]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.WriteRaw(this.____stringByteKeys[2]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Address, options);
            writer.WriteRaw(this.____stringByteKeys[3]);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Description, options);
            writer.WriteRaw(this.____stringByteKeys[4]);
            formatterResolver.GetFormatterWithVerify<byte[]>().Serialize(ref writer, value.ImageBytes, options);
            writer.WriteRaw(this.____stringByteKeys[5]);
            formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponInfo>().Serialize(ref writer, value.WeaponInfo, options);
            writer.WriteRaw(this.____stringByteKeys[6]);
            writer.Write(value.Index);
        }

        public global::Tech.DB.Weapon Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __Id__ = default(byte[]);
            var __Name__ = default(string);
            var __Address__ = default(string);
            var __Description__ = default(string);
            var __ImageBytes__ = default(byte[]);
            var __WeaponInfo__ = default(global::Tech.Data.DB.WeaponInfo);
            var __Index__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                int key;
                if (!this.____keyMapping.TryGetValue(stringKey, out key))
                {
                    reader.Skip();
                    continue;
                }

                switch (key)
                {
                    case 0:
                        __Id__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __Address__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 3:
                        __Description__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 4:
                        __ImageBytes__ = formatterResolver.GetFormatterWithVerify<byte[]>().Deserialize(ref reader, options);
                        break;
                    case 5:
                        __WeaponInfo__ = formatterResolver.GetFormatterWithVerify<global::Tech.Data.DB.WeaponInfo>().Deserialize(ref reader, options);
                        break;
                    case 6:
                        __Index__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.DB.Weapon();
            ____result.Id = __Id__;
            ____result.Name = __Name__;
            ____result.Address = __Address__;
            ____result.Description = __Description__;
            ____result.ImageBytes = __ImageBytes__;
            ____result.WeaponInfo = __WeaponInfo__;
            ____result.Index = __Index__;
            ____result.OnAfterDeserialize();
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters.Tech.Network.Param
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class PlayerFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Tech.Network.Param.Player>
    {


        public void Serialize(ref MessagePackWriter writer, global::Tech.Network.Param.Player value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.Name, options);
            writer.Write(value.Level);
        }

        public global::Tech.Network.Param.Player Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __Name__ = default(string);
            var __Level__ = default(uint);

            for (int i = 0; i < length; i++)
            {
                var key = i;

                switch (key)
                {
                    case 0:
                        __Name__ = formatterResolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __Level__ = reader.ReadUInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Tech.Network.Param.Player();
            ____result.Name = __Name__;
            ____result.Level = __Level__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

